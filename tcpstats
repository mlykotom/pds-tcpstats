#!/usr/bin/python
# -*- coding: utf-8 -*-

import json
import logging
import sys
from operator import itemgetter

import datetime
import dpkt
from dpkt.ip import IP_PROTO_TCP

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
# set current level of loggin #
logger.setLevel(logging.INFO)


class ParserException(Exception):
    pass


class PacketTypeException(ParserException):
    pass


def initial_streamer_output():
    return {
        'mss': 0,
        'ref_seq': 0,
        'speed': [],
        'windows_scale': 0,
        'windows': [],
        'roundtrip': {},
        'expecting_acks': [],
        'seq_numbers': []
    }


class PcapParser:
    SERVER = 'server'
    CLIENT = 'client'

    HANDSHAKE_LEN = 3

    data_sent = {
        'client': 0,
        'server': 0
    }

    client_ip = None
    server_ip = None

    output = {
        'ref_timestamp': 0,
        'server': initial_streamer_output(),
        'client': initial_streamer_output(),
    }

    def __init__(self, filename):
        f = file(filename)
        self.pcap = dpkt.pcap.Reader(f)

    def get_streamer_by_ip(self, ip_address):
        """
        Determines if specified ip address is client or server
        :param ip_address: (string format)
        :return: string (self.SERVER or self.CLIENT)
        """
        if ip_address == self.server_ip:
            return self.SERVER
        elif ip_address == self.client_ip:
            return self.CLIENT
        else:
            raise ParserException("Unknown IP Address")

    def get_streamer_opo(self, streamer):
        if streamer == self.SERVER:
            return self.CLIENT
        else:
            return self.SERVER

    def set_initial(self, timestamp, tcp, ip, syn_flag, ack_flag):
        """
        Setups initial data for TCP stream, should be applied only for first 2 packets (SYN and SYN+ACK)
        :param timestamp: of first packet (reference timestamp)
        :param tcp: dpkt's tcp data
        :param ip: dpkt's ip data
        :param syn_flag: is SYN available
        :param ack_flag: is ACK available
        :return:
        """

        # first packet (handshake way ->)
        if syn_flag and not ack_flag:
            self.client_ip = ip.src
            self.server_ip = ip.dst
            self.output['ref_timestamp'] = timestamp
            self.output['client']['ref_seq'] = tcp.seq

            opts = dpkt.tcp.parse_opts(tcp.opts)
            self.output['client']['windows_scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))
            # self.output['client']['speed'].append([0, 0])
        # second packet (handshake way <-)
        elif syn_flag and ack_flag:
            self.output['server']['ref_seq'] = tcp.seq
            # self.output['mss'] = struct.unpack(">H", self.get_option(opts, dpkt.tcp.TCP_OPT_MSS))[0]
            opts = dpkt.tcp.parse_opts(tcp.opts)
            self.output['server']['windows_scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))
            # self.output['server']['speed'].append([0, 0])
        # third packet (handshake way ->)
        elif not syn_flag and ack_flag:
            pass

    def parse(self):
        p_num = 1  # indexing from 1 because wireshark does that
        for timestamp_raw, buf in self.pcap:
            try:
                tcp, ip, eth, syn_flag, ack_flag = PcapParser.get_tcp_packet(buf)
                if p_num <= self.HANDSHAKE_LEN:
                    self.set_initial(timestamp_raw, tcp, ip, syn_flag, ack_flag)
                    # p_num += 1 # TODO should skip?
                    # continue

                timestamp = (timestamp_raw - self.output['ref_timestamp']) * 1000
                streamer = self.get_streamer_by_ip(ip.src)
                # --- window
                self.append_window_size(streamer, timestamp, tcp.win, p_num)
                # --- speed
                self.append_transfer_speed(streamer, timestamp, buf)
                # --- roundtrip
                self.analyse_rtt(p_num, streamer, timestamp, tcp, ack_flag)

                # if p_num > 65: break
                p_num += 1
            except PacketTypeException as exc:
                logger.debug(exc.message)
                continue

    def analyse_rtt(self, p_num, streamer, timestamp, tcp, ack_flag):
        """
        Analyses roundtrip time
        :param p_num:
        :param streamer:
        :param timestamp:
        :param tcp:
        :param ack_flag:
        """
        if streamer == self.SERVER:
            seq = tcp.seq - self.output['server']['ref_seq']
            ack = tcp.ack - self.output['client']['ref_seq']
        else:
            seq = tcp.seq - self.output['client']['ref_seq']
            ack = tcp.ack - self.output['server']['ref_seq']

        if len(self.output[streamer]['expecting_acks']) > 0:
            prev_packet_expecting = self.output[streamer]['expecting_acks'][-1]
        else:
            prev_packet_expecting = -1

        size = len(tcp.data)
        expecting_ack = size + seq
        if size > 0:
            # TODO check if do different way (size = 0 -> its only ACK, we dont capture packet)
            self.output[streamer]['roundtrip'][expecting_ack] = {
                'p_num': p_num,
                'seq': seq,
                'ack': ack,
                'expecting_ack': expecting_ack,
                'time': timestamp,
                'replied': False,
                'prev_expecting': prev_packet_expecting
            }

        if seq not in self.output[streamer]['seq_numbers']:
            self.output[streamer]['seq_numbers'].append(seq)

        if expecting_ack not in self.output[streamer]['expecting_acks']:
            self.output[streamer]['expecting_acks'].append(expecting_ack)

        # confirmation (rtt)
        if ack_flag:
            streamer_opo = self.get_streamer_opo(streamer)
            self.cumulative_ack(streamer_opo, ack, timestamp)

    def cumulative_ack(self, streamer_opo, ack, timestamp):
        """
        Cumulatively acknowledges packet and it's precedes
        :param streamer_opo:
        :param ack:
        :param timestamp:
        """
        if ack not in self.output[streamer_opo]['roundtrip']:
            return

        packet = self.output[streamer_opo]['roundtrip'][ack]
        if packet['replied']:
            return

        packet['replied'] = True
        packet['time'] = timestamp - packet['time']
        # TODO should check if SEQ is lower or sth like that
        self.cumulative_ack(streamer_opo, packet['prev_expecting'], timestamp)

    @staticmethod
    def get_option(options, opt_type):
        for option in options:
            if option[0] == opt_type:
                return option[1]

    @staticmethod
    def get_tcp_packet(buf):
        """
        Parse one packet from buf and returns various OSI layers.
        Checks if packet is IP && TCP type
        :param buf:
        :return:
        """
        eth = dpkt.ethernet.Ethernet(buf)
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            raise PacketTypeException("Skipping not IP packet")
        ip = eth.data
        if ip.p != IP_PROTO_TCP:
            raise PacketTypeException("Skipping UDP data")

        tcp = ip.data

        syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
        ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0
        return tcp, ip, eth, syn_flag, ack_flag

    @staticmethod
    def get_time(timestamp):
        return str(datetime.datetime.utcfromtimestamp(timestamp))

    def append_window_size(self, streamer, timestamp, win, packet_number):
        """
        Appends to log window
        :param streamer:
        :param timestamp:
        :param win:
        """
        streamer = self.output[streamer]
        if packet_number <= self.HANDSHAKE_LEN:
            scale = 0
        else:
            scale = streamer['windows_scale']

        streamer['windows'].append([timestamp, win << scale])

    def append_transfer_speed(self, streamer, timestamp, buf):
        """
        Appends to log data transfer speed (transfered data / time)
        :param streamer:
        :param timestamp:
        :param buf:
        """
        self.data_sent[streamer] += len(buf)
        if timestamp > 0:
            self.output[streamer]['speed'].append([timestamp, self.data_sent[streamer] / timestamp])
        else:
            self.output[streamer]['speed'].append([0, 0])


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "You need to specify input pcap file!"

    try:
        parser = PcapParser(sys.argv[1])
        parser.parse()

        with open("./log/log.json", 'w') as outfile:
            json.dump(parser.output, outfile)

    except IOError as e:
        print e.strerror
