#!/usr/bin/python
# -*- coding: utf-8 -*-

import json
import logging
import sys
from operator import itemgetter

import datetime
import dpkt
from dpkt.ip import IP_PROTO_TCP

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
# set current level of loggin #
logger.setLevel(logging.INFO)


class ParserException(Exception):
    pass


class PacketTypeException(ParserException):
    pass


class PcapParser:
    SERVER = 'server'
    CLIENT = 'client'

    timestamp_ref = 0
    seq_cli_ref = 0
    seq_srv_ref = 0

    client_ip = None
    server_ip = None

    output = {
        'mss': None,

        'windows': {
            'receiver': {
                'scale': 0,
                'data': []
            },

            'sender': {
                'scale': 0,
                'data': []
            },
        },

        'roundtrip': {
            'client_server': {},
            'server_client': {}
        },
    }

    def __init__(self, filename):
        f = file(filename)
        self.pcap = dpkt.pcap.Reader(f)

    def get_streamer_by_ip(self, ip_addr):
        if ip_addr == self.server_ip:
            return self.SERVER
        elif ip_addr == self.client_ip:
            return self.CLIENT
        else:
            raise ParserException("Unknown IP Address")

    def set_initial(self, timestamp, tcp, ip, syn_flag, ack_flag):
        # first packet (handshake way ->)
        if syn_flag and not ack_flag:
            self.client_ip = ip.src
            self.server_ip = ip.dst
            self.timestamp_ref = timestamp
            self.seq_cli_ref = tcp.seq

            opts = dpkt.tcp.parse_opts(tcp.opts)
            self.output['windows']['sender']['scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))
        # second packet (handshake way <-)
        elif syn_flag and ack_flag:
            self.seq_srv_ref = tcp.seq
            # self.output['mss'] = struct.unpack(">H", self.get_option(opts, dpkt.tcp.TCP_OPT_MSS))[0]
            opts = dpkt.tcp.parse_opts(tcp.opts)
            self.output['windows']['receiver']['scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))

    client_server = []
    server_client = []

    # def find_expected(self, dicts, expected):
    # print dicts
    # return filter(lambda person: person['expecting'] == expected, dicts)

    # return (item for item in dicts if item["expecting"] == expected).next()

    def parse(self):
        ack_counter = 0
        mss = 0
        ts_start = 0
        ts_end = 0

        p_num = 0
        for timestamp_raw, buf in self.pcap:
            try:
                tcp, ip, eth, syn_flag, ack_flag = PcapParser.get_tcp_packet(buf)
                # print socket.inet_ntoa(self.server['ip']), tcp.win

                self.set_initial(timestamp_raw, tcp, ip, syn_flag, ack_flag)

                timestamp = (timestamp_raw - self.timestamp_ref) * 1000
                size = len(tcp.data)

                if self.get_streamer_by_ip(ip.src) == self.SERVER:
                    seq = tcp.seq - self.seq_srv_ref
                    ack = tcp.ack - self.seq_cli_ref

                    self.append_window_size(timestamp, p_num, tcp.win, 'receiver')
                    if p_num > 2:
                        print '<-', "E:", size + seq, "SEQ:", seq, "A:", ack, "SIZE:", size, ack_flag
                        self.output['roundtrip']['server_client'][seq + size] = {
                            'seq': seq,
                            'time': timestamp_raw - self.timestamp_ref
                        }

                    if self.output['roundtrip']['client_server'].has_key(ack):
                        print "FOUND(s) ", ack
                        packet = self.output['roundtrip']['client_server'][ack]
                        packet['time'] = timestamp_raw - self.timestamp_ref - packet['time']


                # ------------- CLIENT
                else:
                    seq = tcp.seq - self.seq_cli_ref
                    ack = tcp.ack - self.seq_srv_ref

                    self.append_window_size(timestamp, p_num, tcp.win, 'sender')
                    if p_num > 2:
                        print '->', "SEQ:", seq, "A:", ack, "SIZE:", size, ack_flag
                        self.output['roundtrip']['client_server'][seq + size] = {
                            'seq': seq,
                            'time': timestamp_raw - self.timestamp_ref
                        }

                        # print self.find_expected(self.output['roundtrip']['server_client'], ack)

                        if self.output['roundtrip']['server_client'].has_key(ack):
                            print "FOUND(c) ", ack
                            packet = self.output['roundtrip']['server_client'][ack]
                            packet['time'] = timestamp_raw - self.timestamp_ref - packet['time']

                            # print ack in self.output['roundtrip']['server_client']


                            # if ack_flag and self.output['roundtrip']['server_client'][ack] is not None:
                            #     print "yuhu"

                # if ack_flag:
                #         ack_counter += 1
                #         mss = self.output['mss'] * ack_counter  # there was +=
                #         # sender window
                #         self.output['windows']['sender'].append([rel_timestamp, mss])
                #         # ts_end = rel_timestamp
                #         self.output['roundtrip']['client_server'].append([packet_num, rel_timestamp - ts_start])
                #         # print ts_end - ts_start
                #     pass
                # else:
                #     ts_start = rel_timestamp
                #     # print rel_seq, rel_timestamp, ack_flag
                #
                #     pass

                p_num += 1

                # if p_num > 10: break

            except PacketTypeException as e:
                logger.debug(e.message)
                continue

                # print self.server_client
                # print sorted(self.server_client)
                # newlist = sorted(self.server_client, key=itemgetter('seq'))
                # print newlist

                # print self.output['roundtrip']['server_client']

    # newlist = sorted(test, key=lambda k: k['seq'])
    # print newlist

    # print x.items()[0][0]

    @staticmethod
    def get_option(options, opt_type):
        for option in options:
            if option[0] == opt_type:
                return option[1]

    @staticmethod
    def get_tcp_packet(buf):
        """
        Checks if packet is IP && TCP type
        :param buf:
        :return:
        """
        eth = dpkt.ethernet.Ethernet(buf)
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            raise PacketTypeException("Skipping not IP packet")
        ip = eth.data
        if ip.p != IP_PROTO_TCP:
            raise PacketTypeException("Skipping UDP data")

        tcp = ip.data

        syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
        ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0
        return tcp, ip, eth, syn_flag, ack_flag

    @staticmethod
    def get_time(timestamp):
        return str(datetime.datetime.utcfromtimestamp(timestamp))

    def append_window_size(self, timestamp, packet_num, win, rec_sen):
        streamer = self.output['windows'][rec_sen]

        if packet_num > 2:
            window = win << streamer['scale']
        else:
            window = win

        streamer['data'].append([timestamp, window])


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "You need to specify input pcap file!"

    try:
        parser = PcapParser(sys.argv[1])
        parser.parse()

        with open("./presenter/log.json", 'w') as outfile:
            json.dump(parser.output, outfile)

    except IOError as e:
        print e.strerror
