#!/usr/bin/python
# -*- coding: utf-8 -*-
import struct

import datetime
import sys
import dpkt
import logging
import socket
import json
from json import JSONEncoder
from dpkt.ip import IP_PROTO_TCP

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
# set current level of loggin #
logger.setLevel(logging.INFO)


class ParserException(Exception):
    pass


class PacketTypeException(ParserException):
    pass


class PcapParser:
    timestamp_ref = 0
    seq_ref = 0

    client_ip = None
    server_ip = None

    output = {
        'roundtrip': {
            'client_server': [],
            'server_client': []
        },

        'mss': None,

        'windows': {
            'receiver': [],
            'receiver_scale': 0,
            'sender': [],
        }
    }

    def __init__(self, filename):
        f = file(filename)
        self.pcap = dpkt.pcap.Reader(f)

    def get_streamer_by_ip(self, ip_addr):
        if ip_addr == self.server_ip:
            return 'server'
        elif ip_addr == self.client_ip:
            return 'client'
        else:
            raise ParserException("Unknown IP Address")

    def set_initial_data(self, timestamp, tcp, ip):
        self.client_ip = ip.src
        self.server_ip = ip.dst
        self.timestamp_ref = timestamp
        self.seq_ref = tcp.seq
        pass

    def parse(self):
        ack_counter = 0
        mss = 0
        ts_start = 0
        ts_back = 0
        ts_end = 0
        for timestamp, buf in self.pcap:
            try:
                tcp, ip, eth = PcapParser.get_tcp_packet(buf)
                # print socket.inet_ntoa(self.server['ip']), tcp.win
                syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
                ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0

                # first packet (handshake way ->)
                if syn_flag and not ack_flag:
                    self.set_initial_data(timestamp, tcp, ip)
                # second packet (handshake way <-)
                elif syn_flag and ack_flag:
                    opts = dpkt.tcp.parse_opts(tcp.opts)
                    self.output['mss'] = struct.unpack(">H", self.get_option(opts, dpkt.tcp.TCP_OPT_MSS))[0]
                    self.output['receiver_scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))

                rel_timestamp = (timestamp - self.timestamp_ref) * 1000
                rel_seq = tcp.seq - self.seq_ref

                if self.get_streamer_by_ip(ip.src) == 'server':
                    # receiver window
                    if not (syn_flag and ack_flag):
                        window = tcp.win << self.output['receiver_scale']
                    else:
                        window = tcp.win

                    self.output['windows']['receiver'].append([rel_timestamp, window])

                    if ack_flag:
                        ack_counter += 1
                        mss = self.output['mss'] * ack_counter  # there was +=
                        # sender window
                        self.output['windows']['sender'].append([rel_timestamp, mss])
                else:
                    # print rel_seq, rel_timestamp, ack_flag

                    pass

            except PacketTypeException as e:
                logger.debug(e.message)
                continue

    @staticmethod
    def get_option(options, type):
        for option in options:
            if option[0] == type:
                # The MSS is a 16 bit number   dpkt decodes it as a 16
                # bit number.  An MSS is never going to be bigger than 65496 bytes.
                # The most common value is 1460 bytes (IPv4) which 0x05b4 or 1440 bytes (IPv6) which is 0x05a0.  The format string ">H" means
                # big-endian unsigned 16 bit number.  It should be ">L" which is big-endian 32 bit number.
                return option[1]

    @staticmethod
    def get_tcp_packet(buf):
        """
        Checks if packet is IP && TCP type
        :param buf:
        :return:
        """
        eth = dpkt.ethernet.Ethernet(buf)
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            raise PacketTypeException("Skipping not IP packet")
        ip = eth.data
        if ip.p != IP_PROTO_TCP:
            raise PacketTypeException("Skipping UDP data")

        tcp = ip.data
        return tcp, ip, eth

    @staticmethod
    def get_time(timestamp):
        return str(datetime.datetime.utcfromtimestamp(timestamp))

        # def parse_rtt(self):
        #     ts_start = ts_back = ts_end = 0
        #     for timestamp, tcp, ip, eth in self.packets:
        #         syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
        #         ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0
        #
        #         # from server (2nd way)
        #         if syn_flag and ack_flag:
        #             ts_back = timestamp
        #         # from client (1nd way)
        #         elif syn_flag:
        #             ts_start = timestamp
        #         # from server (3nd way)
        #         elif ack_flag:
        #             ts_end = timestamp
        #
        #         if ts_start and ts_back and ts_end: break
        #     rtt = ts_back + ts_end - 2 * ts_start
        #     return rtt


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "You need to specify input pcap file!"

    try:
        parser = PcapParser(sys.argv[1])
        parser.parse()

        # output = {
        #     'client': parser.client,
        #     'server': parser.server
        # }

        with open("./presenter/log.json", 'w') as outfile:
            json.dump(parser.output, outfile)

    except IOError as e:
        print e.strerror
