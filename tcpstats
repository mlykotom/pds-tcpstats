#!/usr/bin/python
# -*- coding: utf-8 -*-

import json
import logging
import sys
from operator import itemgetter

import datetime
import dpkt
from dpkt.ip import IP_PROTO_TCP

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
# set current level of loggin #
logger.setLevel(logging.INFO)


class ParserException(Exception):
    pass


class PacketTypeException(ParserException):
    pass


class PcapParser:
    SERVER = 'server'
    CLIENT = 'client'

    data_size = 0

    ref = {
        'client': {
            'seq': 0
        },
        'server': {
            'seq': 0
        },
        'timestamp': 0
    }

    client_ip = None
    server_ip = None

    output = {
        'mss': None,

        'server': {
            'speed': []
        },

        'client': {
            'speed': []
        },

        'windows': {
            'server': {
                'scale': 0,
                'data': []
            },

            'client': {
                'scale': 0,
                'data': []
            },
        },

        'roundtrip': {
            'client_server': {},
            'server_client': {}
        },
    }

    def __init__(self, filename):
        f = file(filename)
        self.pcap = dpkt.pcap.Reader(f)

    def get_streamer_by_ip(self, ip_addr):
        """
        Determines if specified ip address is client or server
        :param ip_addr: (string format)
        :return: string (self.SERVER or self.CLIENT)
        """
        if ip_addr == self.server_ip:
            return self.SERVER
        elif ip_addr == self.client_ip:
            return self.CLIENT
        else:
            raise ParserException("Unknown IP Address")

    def set_initial(self, timestamp, tcp, ip, syn_flag, ack_flag):
        """
        Setups initial data for TCP stream, should be applied only for first 2 packets (SYN and SYN+ACK)
        :param timestamp: of first packet (reference timestamp)
        :param tcp: dpkt's tcp data
        :param ip: dpkt's ip data
        :param syn_flag: is SYN available
        :param ack_flag: is ACK available
        :return:
        """

        # first packet (handshake way ->)
        if syn_flag and not ack_flag:
            self.client_ip = ip.src
            self.server_ip = ip.dst
            self.ref['timestamp'] = timestamp
            self.ref['client']['seq'] = tcp.seq

            opts = dpkt.tcp.parse_opts(tcp.opts)
            self.output['windows']['client']['scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))
            self.output['client']['speed'].append([0, 0])

        # second packet (handshake way <-)
        elif syn_flag and ack_flag:
            self.ref['server']['seq'] = tcp.seq
            # self.output['mss'] = struct.unpack(">H", self.get_option(opts, dpkt.tcp.TCP_OPT_MSS))[0]
            opts = dpkt.tcp.parse_opts(tcp.opts)
            self.output['windows']['server']['scale'] = ord(self.get_option(opts, dpkt.tcp.TCP_OPT_WSCALE))
            self.output['server']['speed'].append([0, 0])
        # third packet (handshake way ->)
        elif not syn_flag and ack_flag:
            pass

    # def find_expected(self, dicts, expected):
    # print dicts
    # return filter(lambda person: person['expecting'] == expected, dicts)
    # return (item for item in dicts if item["expecting"] == expected).next()

    def parse(self):
        p_num = 1  # indexing from 1 because wireshark does that
        data_size = 0
        for timestamp_raw, buf in self.pcap:
            try:
                tcp, ip, eth, syn_flag, ack_flag = PcapParser.get_tcp_packet(buf)
                # print socket.inet_ntoa(self.server['ip']), tcp.win

                if p_num <= 3:
                    self.set_initial(timestamp_raw, tcp, ip, syn_flag, ack_flag)
                    p_num += 1
                    continue

                timestamp = (timestamp_raw - self.ref['timestamp']) * 1000
                size = len(tcp.data)
                streamer = self.get_streamer_by_ip(ip.src)
                # --- window
                self.append_window_size(streamer, timestamp, tcp.win)
                # --- speed
                self.append_transfer_speed(streamer, timestamp, buf)

                # if streamer == self.SERVER:
                #     seq = tcp.seq - self.ref['server']['seq']
                #     ack = tcp.ack - self.ref['client']['seq']
                #     namespace = 'server_client'
                #     namespace_opo = 'client_server'
                #     chrobok = '<-'
                # else:
                #     seq = tcp.seq - self.ref['client']['seq']
                #     ack = tcp.ack - self.ref['server']['seq']
                #     namespace = 'client_server'
                #     namespace_opo = 'server_client'
                #     chrobok = '->'
                #
                # print p_num, chrobok, "SEQ:", seq, "E:", size + seq, "A:", ack, "SIZE:", size, timestamp
                #
                # is_captured = self.output['roundtrip'][namespace].has_key(seq)
                # if is_captured is False:
                #     self.output['roundtrip'][namespace][seq] = {
                #         'p_num': p_num,
                #         'seq': seq,
                #         'ack': ack,
                #         'time': timestamp,
                #         'replied': 0
                #     }
                # else:
                #     print "problem", p_num

                # confirmation (rtt)
                # if ack_flag and self.output['roundtrip'][namespace_opo].has_key(ack):
                #     packet = self.output['roundtrip'][namespace_opo][ack]
                #     packet['replied'] += 1
                #     if packet['replied'] == 1:
                #         packet['p_conf'] = p_num
                #         packet['time'] = timestamp - packet['time']

                p_num += 1
                # if p_num > 100: break
            except PacketTypeException as e:
                logger.debug(e.message)
                continue

                # print self.server_client
                # print sorted(self.server_client)
                # newlist = sorted(self.server_client, key=itemgetter('seq'))
                # print newlist

                # print self.output['roundtrip']['server_client']

                # newlist = sorted(self.output['roundtrip']['server_client'], key=lambda k: k['seq'])
                # print newlist

    @staticmethod
    def get_option(options, opt_type):
        for option in options:
            if option[0] == opt_type:
                return option[1]

    @staticmethod
    def get_tcp_packet(buf):
        """
        Checks if packet is IP && TCP type
        :param buf:
        :return:
        """
        eth = dpkt.ethernet.Ethernet(buf)
        if eth.type != dpkt.ethernet.ETH_TYPE_IP:
            raise PacketTypeException("Skipping not IP packet")
        ip = eth.data
        if ip.p != IP_PROTO_TCP:
            raise PacketTypeException("Skipping UDP data")

        tcp = ip.data

        syn_flag = (tcp.flags & dpkt.tcp.TH_SYN) != 0
        ack_flag = (tcp.flags & dpkt.tcp.TH_ACK) != 0
        return tcp, ip, eth, syn_flag, ack_flag

    @staticmethod
    def get_time(timestamp):
        return str(datetime.datetime.utcfromtimestamp(timestamp))

    def append_window_size(self, streamer, timestamp, win):
        streamer = self.output['windows'][streamer]
        streamer['data'].append([timestamp, win << streamer['scale']])

    def append_transfer_speed(self, streamer, timestamp, buf):
        self.data_size += len(buf)
        self.output[streamer]['speed'].append([timestamp, self.data_size / timestamp])


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print "You need to specify input pcap file!"

    try:
        parser = PcapParser(sys.argv[1])
        parser.parse()

        with open("./log/log.json", 'w') as outfile:
            json.dump(parser.output, outfile)

    except IOError as e:
        print e.strerror
